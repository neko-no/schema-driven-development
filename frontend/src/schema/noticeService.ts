/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Notice Service
 * OpenAPI spec version: 0.0.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

export type BadRequestErrorCode = typeof BadRequestErrorCode[keyof typeof BadRequestErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BadRequestErrorCode = {
  BAD_REQUEST: 'BAD_REQUEST',
} as const;

export interface BadRequestError {
  code: BadRequestErrorCode;
  message: string;
}

export type InternalServerErrorCode = typeof InternalServerErrorCode[keyof typeof InternalServerErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InternalServerErrorCode = {
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
} as const;

export interface InternalServerError {
  code: InternalServerErrorCode;
  message: string;
}

export type NotFoundErrorCode = typeof NotFoundErrorCode[keyof typeof NotFoundErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotFoundErrorCode = {
  NOT_FOUND: 'NOT_FOUND',
} as const;

export interface NotFoundError {
  code: NotFoundErrorCode;
  message: string;
}

export interface Notice {
  id: number;
  title: string;
  content: string;
  released_at: string;
  created_at: string;
  updated_at: string;
}

export interface SDDServiceValidationErrorResponse {
  /** The body type of the operation request or response. */
  body: ValidationError;
}

export type ValidationErrorCode = typeof ValidationErrorCode[keyof typeof ValidationErrorCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ValidationErrorCode = {
  VALIDATION_ERROR: 'VALIDATION_ERROR',
} as const;

export interface ValidationError {
  code: ValidationErrorCode;
  message: string;
  date: string[];
}

export type NoticesServiceGetNoticesParams = {
page?: number;
limit?: number;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Get all notices
 * @summary Retrive all notices
 */
export const getNoticesServiceGetNoticesUrl = (params?: NoticesServiceGetNoticesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/notices?${stringifiedParams}` : `/notices`
}

export const noticesServiceGetNotices = async (params?: NoticesServiceGetNoticesParams, options?: RequestInit): Promise<Notice[]> => {
  
  const res = await fetch(getNoticesServiceGetNoticesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Notice[] = body ? JSON.parse(body) : {}

  return data
}



export const getNoticesServiceGetNoticesQueryKey = (params?: NoticesServiceGetNoticesParams,) => {
    return [`/notices`, ...(params ? [params]: [])] as const;
    }

    
export const getNoticesServiceGetNoticesQueryOptions = <TData = Awaited<ReturnType<typeof noticesServiceGetNotices>>, TError = BadRequestError | InternalServerError>(params?: NoticesServiceGetNoticesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof noticesServiceGetNotices>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNoticesServiceGetNoticesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof noticesServiceGetNotices>>> = ({ signal }) => noticesServiceGetNotices(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof noticesServiceGetNotices>>, TError, TData> & { queryKey: QueryKey }
}

export type NoticesServiceGetNoticesQueryResult = NonNullable<Awaited<ReturnType<typeof noticesServiceGetNotices>>>
export type NoticesServiceGetNoticesQueryError = BadRequestError | InternalServerError


/**
 * @summary Retrive all notices
 */

export function useNoticesServiceGetNotices<TData = Awaited<ReturnType<typeof noticesServiceGetNotices>>, TError = BadRequestError | InternalServerError>(
 params?: NoticesServiceGetNoticesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof noticesServiceGetNotices>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNoticesServiceGetNoticesQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific notice by ID
 * @summary Retrice a notice by ID
 */
export const getNoticesServiceGetNoticeUrl = (id: string,) => {


  

  return `/notices/${id}`
}

export const noticesServiceGetNotice = async (id: string, options?: RequestInit): Promise<Notice> => {
  
  const res = await fetch(getNoticesServiceGetNoticeUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: Notice = body ? JSON.parse(body) : {}

  return data
}



export const getNoticesServiceGetNoticeQueryKey = (id?: string,) => {
    return [`/notices/${id}`] as const;
    }

    
export const getNoticesServiceGetNoticeQueryOptions = <TData = Awaited<ReturnType<typeof noticesServiceGetNotice>>, TError = BadRequestError | NotFoundError | InternalServerError>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof noticesServiceGetNotice>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNoticesServiceGetNoticeQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof noticesServiceGetNotice>>> = ({ signal }) => noticesServiceGetNotice(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof noticesServiceGetNotice>>, TError, TData> & { queryKey: QueryKey }
}

export type NoticesServiceGetNoticeQueryResult = NonNullable<Awaited<ReturnType<typeof noticesServiceGetNotice>>>
export type NoticesServiceGetNoticeQueryError = BadRequestError | NotFoundError | InternalServerError


/**
 * @summary Retrice a notice by ID
 */

export function useNoticesServiceGetNotice<TData = Awaited<ReturnType<typeof noticesServiceGetNotice>>, TError = BadRequestError | NotFoundError | InternalServerError>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof noticesServiceGetNotice>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getNoticesServiceGetNoticeQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const getNoticesServiceGetNoticesResponseMock = (): Notice[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.number.int({min: undefined, max: undefined}), title: faker.string.alpha({length: {min: 10, max: 20}}), content: faker.string.alpha({length: {min: 10, max: 20}}), released_at: faker.date.past().toISOString().split('T')[0], created_at: `${faker.date.past().toISOString().split('.')[0]}Z`, updated_at: `${faker.date.past().toISOString().split('.')[0]}Z`})))

export const getNoticesServiceGetNoticeResponseMock = (): Notice => ({"id":1,"title":"Notice Title","content":"Notice Content","released_at":"2025-08-10T00:00:00Z","created_at":"2025-08-10T00:00:00Z","updated_at":"2025-08-10T00:00:00Z"})


export const getNoticesServiceGetNoticesMockHandler = (overrideResponse?: Notice[] | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Notice[]> | Notice[])) => {
  return http.get('*/notices', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getNoticesServiceGetNoticesResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getNoticesServiceGetNoticeMockHandler = (overrideResponse?: Notice | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Notice> | Notice)) => {
  return http.get('*/notices/:id', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getNoticesServiceGetNoticeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getNoticeServiceMock = () => [
  getNoticesServiceGetNoticesMockHandler(),
  getNoticesServiceGetNoticeMockHandler()
]
